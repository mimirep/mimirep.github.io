---
layout: post
title: "온라인 방사성탄소연대 데이터베이스[RCDB](2)"
tags: [Radiocarbondating]
comments: true
use_math: true
---

<center><img src="https://github.com/ChanToRe/RCDB/blob/master/img/Info_IMG.png?raw=true"></center>

<br>

### 1. 계획

​	온라인 방사성탄소연대 데이터베이스(이하 RCDB)는 총 4개의 화면을 가집니다. 접속했을 때 처음 나타날 Main, RCDB의 간단한 소개가 담긴 Info, RCDB의 기능 및 데이터 업로드 상황이 추가되는 Notice, 핵심 기능으로 데이터가 엑셀 화면으로 출력되는 RCDB으로 구성됩니다.

​	Main과 Info는 간단히 하나의 페이지만 출력될 예정이기 때문에 intex.html만 연결해주었고 Notice는 출력화면인 Notice_list와 세부내용화면인 Notice_detail로 모델을 구성해주었습니다. 

​	RCDB는 사전에 기획한 것에 따라 아래의 표에 기재되어 있는 것처럼 구성하였습니다. 가장 앞에 부여될 시료의 고유한 ID는 자동으로 부여되게 설정했습니다.

|   Column   | Explanation                                                  |
| :--------: | :----------------------------------------------------------- |
|    Name    | 발굴조사 기관 혹은 연대측정 기관이 부여한 시료의 이름        |
|   State    | 시료가 발굴된 대지역 (대한민국 행정구역 중 광역시 · 도 단위) |
|    City    | 시료가 발굴된 중지역 (대한민국 행정구역 중 시 · 군 · 자치구 단위) |
|    Site    | 시료가 발굴된 소지역 + 유적과 유구 (대한민국 행정구역 중 읍 · 면 · 동 · 리 및 유구 이름) |
| Marterial  | 시료의 재질                                                  |
|  Weight_g  | 시료의 무게, g단위                                           |
| Laboratory | 방사성탄소연대측정을 실시한 기관                             |
|   LabID    | 방사성탄소연대측정을 실시한 기관이 부여한 시료의 고유한 ID   |
|   Age_BP   | 측정된 연대로 보정이 되지 않은 연대, BP 단위                 |
|   Error    | 측정된 연대의 오차 (±)                                       |
|   Report   | 시료가 발굴된 유적 및 유구의 발굴조사보고서                  |

<br>

### 2. 구조

```bash
│
├── config/
│   ├── __init__.py
│   ├── asgi.py
│   ├── urls.py
│   ├── wsgi.py
│   └── settings.py
│
├── main/
├── info/
│
├── notice/
│   ├── migrations/
│   ├── __init__.py
│   ├── apps.py
│   ├── tests.py
│   ├── urls.py
│   ├── views.py
│   ├── models.py
│   └── admin.py
│ 
├── rcdb/
│   ├── migrations/
│   ├── __init__.py
│   ├── apps.py
│   ├── tests.py
│   ├── urls.py
│   ├── views.py
│   ├── models.py
│   └── admin.py
│ 
├── dbsqlite3.db
├── img/
├── .gitignore
├── manage.py
├── static/
└── templates/
```

​	config/urls.py를 각 App들의 urls.py와 연결하여 관리하게 해주었다. img/에는 각종 이미지 파일을 넣어주었고 img에 들어가는 이미지 파일들은 정수은님께서 디자인해주셨다. static/에는 css, js 파일 등을 넣어주었으며, templates/에는 각 App별로 html이 관리될 수 있게 해주었다. 

​	개발을 하면서 초창기에는 보안을 위해 config/settings.py를 release.py와 local.py로 나누어 관리하고자 하였으나, 코드가 뒤엉켜서 Migration 에러가 발생하였다. 문득 '보안을 위해서라면 .gitignore를 통해 Github에 올리지 않으면 되는 것이 아닌가?' 라는 생각이 떠올랐고 release.py와 local.py를 다시 settings.py로 통합해준 뒤, .gitignore를 추가해주었다.

<br>

### 3. Main과 Info

#### [Main](http://rcdb.kr/) <- rcdb.kr/main

​	Main은 서비스에 접속했을 때 가장 먼저 보이는 화면이다. Google에 Free archaeology Illustration을 검색하여 적절한 이미지를 삽입해주었고, 각 App들이 어떤 역할인지 간략하게 요약해둔 뒤, 링크를 걸어주었다.

#### [Info](http://rcdb.kr/info/) <- rcdb.kr/info

​	Info는 RCDB가 어떤 서비스인지 설명해주는 화면이다. RCDB의 필요성을 간단하게 피력한 뒤, 팀원소개, 기술스택이 설명되게 적어두었다.

<br>

### 4. Notice

#### [Notice](http://rcdb.kr/notice/)

```python
#notice/models.py

from django.db import models
from django.db.models.base import Model, ModelStateFieldsCacheDescriptor

class Notice(models.Model):
    subject = models.CharField(max_length=100)
    content = models.TextField()
    create_date = models.DateTimeField()
    
    def __str__(self):
        return self.subject
```

​	Notice는 공지 게시판의 기능을 하는 App이다. 간단한 공지이기 때문에 크게 Subject, Content, Date만 담고 있으면 된다. models.py는 이러한 세개의 값만 가지도록 설정해주었다.

```python
#/notice/urls.py

from django.urls import path
from . import views

app_name = 'notice'

urlpatterns = [
    path('', views.index, name='index'),
    path('<int:notice_id>/', views.detail, name='detail'),
]
```

​	앞서 말했다시피, 각 App들의 urls.py를 만들어 config/urls.py와 연결해주었다. 이 때 공지에 id를 자동적으로 부여되게 했다. 

```python
#notice/views.py

from django.shortcuts import get_object_or_404, render
from django.http import HttpResponse
from .models import Notice
from django.core.paginator import Paginator

def index(request):
    notice_list = Notice.objects.order_by('-create_date')
    context = {'notice_list': notice_list}
    return render(request, 'notice/notice_list.html', context)

def detail(request, notice_id):
    notice = get_object_or_404(Notice, pk=notice_id)
    context = {'notice' : notice}
    return render(request, 'notice/notice_detail.html', context)

def index(request):
    page = request.GET.get('page', '1')
    notice_list = Notice.objects.order_by('-create_date')
    paginator = Paginator(notice_list, 15)
    page_obj = paginator.get_page(page)
    context = {'notice_list': page_obj}
    return render(request, 'notice/notice_list.html', context)
```

​	Notice는 list 화면과 detail 화면으로 구분된다. list에는 자동적으로 추가되는 id 외에 Subject, Date가 표시된다. templates/notice/notice_list.html과 연결되게 해주었다. detail은 공지사항의 세부 내용이 표시된다. models.py에서 받은 값들이 출력되며, templates/notice/notice_detail.html와 연결해주었다.

​	notice의 양이 많아질 것을 대비해 Pagination을 적용해주었다. 1 page 당 15개의 notice가 출력된다.

<br>

### 5. RCDB

```python
#rcdb/models.py

from django.db import models
from django.db.models.base import Model, ModelStateFieldsCacheDescriptor
from django.db.models.fields import TextField
from django.db.models.fields.reverse_related import ManyToOneRel

class rcdb(models.Model):
    Name = models.CharField(max_length=11)
    State = models.CharField(max_length=15)
    City = models.CharField(max_length=15)
    Site = models.CharField(max_length=15)
    Material = models.CharField(max_length=15)
    Weight_g = models.FloatField()
    Laboratory = models.CharField(max_length=15)
    LabID = models.CharField(max_length=15)
    Age_BP = models.IntegerField()
    Error = models.IntegerField()
    Report = models.TextField()
```

​	RCDB는 방사성탄소연대데이터를 엑셀처럼 출력시켜주는 기능의 App이다. 엑셀처럼 출력되는 것은 물론이고, 필터링 및 CSV Export 기능까지 지원된다. models.py에서 받는 값들은 모두 방사성탄소연대 활용시 필수적으로 알아야하는 값들이다.

​	Name은 발굴조사기관이나 방사성탄소연대측정기관에서 부여한 시료의 이름이다. Name만으로는 간혹 중복되는 것들이 있을 수 있기 때문에 Laboratory와 Laboratory에서 부여한 LabID를 추가해주었다.

​	시료의 재료는 한자어 기준으로 입력할 예정이고, 무게는 g 단위를 사용했다.

​	지역을 State, City, Site로 구분한 이유는 지역 검색을 원활하게 하기 위해서다. 지역을 대지역, 중지역, 유적 및 유구로 구분한 것인데, 이렇게 함으로써 필터링할 때 더욱 세부적으로 할 수 있다. 

​	가장 중요한 방사성탄소연대는 BP를 기준으로 하며 검색을 원활하게 하기 위해 오차인 Error를 별도의 Column으로 설정해주었다.

​	Report의 경우 시료의 분석표를 보기 원활하게 하기 위해 발굴조사보고서의 이름을 그대로 넣어주었다. 

```python
#rcdb/urls.py

from django.urls import path
from . import views

app_name = 'rcdb'

urlpatterns = [
    path('', views.index, name='index'),
]
```

​	앞선 Notice 처럼, 각 App들의 urls.py를 만들어 config/urls.py와 연결해주었기 때문에 rcdb App 내부에도 urls.py를 설정하여 연결해주었다. 

```python
#rcdb/views.py

from django.shortcuts import render
from django.http import HttpResponse
from .models import rcdb
from django.contrib.auth.models import User
from django.core import serializers
import json

def index(request):
    rcdbsDict = []

    for data in rcdb.objects.all():
        tmpdict = {
            "id" : data.id,
            "Name" : data.Name,
            "State" : data.State,
            "City": data.City,
            "Site" : data.Site,
            "Material" : data.Material,
            "Weight_g" : data.Weight_g,
            "Laboratory" : data.Laboratory,
            "LabID" : data.LabID,
            "Age_BP" : data.Age_BP,
            "Error" : data.Error,
            "Report" : data.Report
        }
        rcdbsDict.append(tmpdict)

    rcdbsJson = json.dumps(rcdbsDict, ensure_ascii=False)
    context = {'rcdbsJson' : rcdbsJson}
    return render(request, 'rcdb/index.html', context)
```

​	models.py에서 입력받는 값들을 Javascript를 활용하여 비동기방식으로 출력하기 위해서는 데이터를 JSON으로 변환해주어야한다. 기존에는 간단하게 serializers를 사용하려고 했다. 성공적으로 JSON으로 변환되기는 했으나 한글이 깨지고 Handsontable에 적용하는 중 코드가 꼬이는 문제가 발생하였다. 때문에 Front-end 개발자인 김지훈님께서 수정하였다. 

​	코드를 살펴보자면, 먼저 빈 rcdbsDict 리스트를 생성해주고, models.py에서 입력받는 값들을 tmpdict로 받은 뒤, 이를 그대로 rcdbsDict에 추가해주었다. 이를 json.dumps를 사용하여 json으로 변환해주었고, templates/rcdb/index.html의 Javascript 코드와 연결해주어 엑셀로 출력되게 했다.

<br>

### 6. Release

​	배포를 위해 Gabia에서 rcdb.kr이라는 도메인을 구매했다. 비영리 목적이기 때문에 .org를 구매하고 싶었으나 이미 사용중인 도메인이었고, .or.kr은 왜인지 모르겠으나 가격이 비쌌다. 때문에 아쉽게도 rcdb.kr로 구매했다.

Gunicorn

```bash
[Unit]
Description=gunicorn daemon
After=network.target

[Service]
User=-----
Group=-----
WorkingDirectory=/-----/-----/-----/-----/
EnvironmentFile=/-----/-----/-----/-----/
ExecStart=/-----/-----/-----/-----/-----/-----
        --workers ----- \
        --bind unix:/tmp/gunicorn.sock \
        config.wsgi:application
[Install]
WantedBy=multi-user.target
```

​	HttpRequest를 Python이 알아듣게 해주기 위해 Gunicorn을 사용해주었다. 설정은 위와같으며 보안상 디렉토리 구조의 노출을 최소화하기 위해 대쉬 처리를 했다.

Nginx

```nginx
server {
        listen -----;
        server_name -----;

        location = /favicon.ico { access_log off; log_not_found off; }

        location /----- {
                alias /-----/-----/-----/-----/-----;
        }

        location / {
                include proxy_params;
                proxy_pass http://unix:/tmp/gunicorn.sock;
        }
}
```

​	마지막으로 웹서버 Nginx를 설치해 주었다. 설정은 위와 같으며 보안상 디렉토리 구조의 노출을 최소화하기 위해 대쉬 처리를 했다.

<br>

### 7. 배포 이후

​	서비스를 할 환경은 모두 갖추었다. 이제 데이터만 크롤링해서 넣어주면 되는데 한 가지 문제점이 생겼다. 바로 데이터 크롤링이 불가능하다는 점이다. 크롤링이 불가능하게 하는 몇가지 요인이 있는데, 1. 데이터가 문화재청 내부망에 존재, 2. 문화재청이 공개한 것들을 별도의 다운로더를 사용하 배포, 3. 오래된 발굴조사보고서들의 경우 Text가 아닌 이미지로 저장 등이다.

​	Beautifulsoup을 활용하여 크롤링하는 것은 사실상 불가능해졌고, OpenCV를 사용하여 긁어올까도 생각해보았지만 애초에 발굴조사보고서를 크롤링하는 것이 불가능하기 때문에 별 소용이 없어보인다. 결국 데이터는 직접 보면서 찾아야한다. 하루에 보고서 20개씩 보면서 데이터를 기입해나갈 예정이며 대학원 입시가 끝나는대로 양을 늘리고 팀원을 구해볼 생각이다.

​	RCDB가 연구자들에게 많은 많은 도움이 되기를 기원한다.
